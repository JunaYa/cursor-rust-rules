---
description:
globs:
alwaysApply: false
---
# 🦀 RUST CORE CODE QUALITY STANDARDS

> **TL;DR:** Essential code quality rules for all Rust projects, focusing on maintainable, production-ready code that follows modern Rust 2024 idioms.

## 🎯 FUNDAMENTAL PRINCIPLES

### Code Organization
- **Functionality-based files**: Use meaningful file names like `user.rs`, `product.rs`, `auth.rs` instead of generic `models.rs`, `traits.rs`, `types.rs`
- **Meaningful naming**: Avoid names like `UserServiceImpl` - use descriptive, specific names
- **File size limits**: Maximum 500 lines per file (excluding tests)
- **Function size**: Maximum 150 lines per function
- **Single Responsibility**: Each module should have one clear purpose

### Rust Edition and Safety
- **Always use Rust 2024 edition**
- **Never use `unsafe` code** - find safe alternatives
- **Production-ready code**: All code must be deployable and maintainable
- **No `unwrap()` or `expect()`** in production code - use proper error handling

## 📦 DEPENDENCY MANAGEMENT

### Workspace Dependencies Priority
```toml
# Always prefer workspace dependencies first
[dependencies]
tokio = { workspace = true }
serde = { workspace = true, features = ["derive"] }

# Only add new dependencies if not available in workspace
# Request permission before modifying Cargo.toml
```

### Standard Crate Recommendations
When adding new dependencies, prefer these battle-tested crates:

```toml
# Core utilities
anyhow = "1.0"                               # Error handling
thiserror = "2.0"                           # Error type definitions
derive_more = { version = "2", features = ["full"] }  # Extended derive macros
typed-builder = "0.21"                      # Builder pattern

# Async/Concurrency
tokio = { version = "1.45", features = [
    "macros",
    "rt-multi-thread",
    "signal",
    "sync"
] }
async-trait = "0.1"                         # Async traits
futures = "0.3"                             # Async utilities
dashmap = { version = "6", features = ["serde"] }  # Concurrent HashMap

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
base64 = "0.22"

# Web/HTTP
axum = { version = "0.8", features = ["macros", "http2"] }
reqwest = { version = "0.12", default-features = false, features = [
    "charset",
    "rustls-tls-webpki-roots",
    "http2",
    "json",
    "cookies",
    "gzip",
    "brotli",
    "zstd",
    "deflate"
] }
tower = { version = "0.5", features = ["util"] }
tower-http = { version = "0.6", features = ["cors", "trace"] }
http = "1"

# Database
sqlx = { version = "0.8", features = [
    "chrono",
    "postgres",
    "runtime-tokio-rustls",
    "sqlite",
    "time",
    "uuid"
] }

# Documentation/API
utoipa = { version = "5", features = ["axum_extras"] }
utoipa-axum = { version = "0.2" }
utoipa-swagger-ui = { version = "9", features = [
    "axum",
    "vendored"
], default-features = false }
schemars = { version = "0.8", features = ["chrono", "url"] }

# Time/Date
chrono = { version = "0.4", features = ["serde"] }
time = { version = "0.3", features = ["serde"] }

# Templating/Text Processing
minijinja = { version = "2", features = [
    "json",
    "loader",
    "loop_controls",
    "speedups"
] }
regex = "1"
htmd = "0.2"                                # HTML to Markdown

# Authentication/Security
jsonwebtoken = "9.0"
uuid = { version = "1.17", features = ["v4", "serde"] }

# Data Processing
jsonpath-rust = "1"
url = "2.5"

# CLI (when needed)
clap = { version = "4.0", features = ["derive"] }

# Utilities
rand = "0.8"
getrandom = "0.3"
atomic_enum = "0.3"                         # Atomic enumerations

# Logging/Observability
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

### Version Strategy
- **Always use latest versions** when adding new dependencies
- **Request permission** before modifying `Cargo.toml`
- **Check workspace first** - never duplicate dependencies unnecessarily
- **Use specific feature flags** to minimize compilation time and binary size
- **Prefer rustls over openssl** for TLS (better for cross-compilation)

## 🏗️ CODE STRUCTURE PATTERNS

### Data Structure Organization
```rust
// ✅ Good: Functionality-based organization
// src/user.rs - All user-related types and logic
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]  // Always use camelCase for JSON serialization
pub struct User {
    pub user_id: String,
    pub display_name: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
}

// ✅ Good: Meaningful trait names
pub trait UserValidator {
    fn validate(&self, user: &User) -> Result<(), ValidationError>;
}

// ❌ Bad: Generic file organization
// src/models.rs, src/traits.rs, src/types.rs
// ❌ Bad: Poor naming
// struct UserValidatorImpl
```

### Serde Configuration
```rust
// ✅ Always use camelCase for JSON serialization
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ApiResponse {
    pub user_id: String,
    pub created_at: DateTime<Utc>,
    pub is_active: bool,
}

// This serializes to:
// {"userId": "...", "createdAt": "...", "isActive": true}
```

## 🔧 BUILD AND QUALITY CHECKS

### Mandatory Verification Steps
After completing any code changes, **always run in order**:

```bash
# 1. Build check
cargo build

# 2. Test execution
cargo test

# 3. Linting
cargo clippy

# All must pass before considering code complete
```

### Clippy Configuration
```toml
# Cargo.toml
[lints.clippy]
all = "warn"
pedantic = "warn"
nursery = "warn"
unwrap_used = "deny"
expect_used = "deny"
```

## 🗂️ FILE NAMING CONVENTIONS

### Module Organization Patterns
```rust
// ✅ Good: Feature-based modules
src/
├── user/
│   ├── mod.rs
│   ├── service.rs       // UserService logic
│   ├── repository.rs    // User data access
│   └── validator.rs     // User validation
├── product/
│   ├── mod.rs
│   ├── catalog.rs       // Product catalog logic
│   └── pricing.rs       // Product pricing logic
└── auth/
    ├── mod.rs
    ├── token.rs         // Token management
    └── session.rs       // Session handling
```

### Naming Best Practices
```rust
// ✅ Good naming examples
pub struct UserService;                // Clear, specific
pub struct ProductCatalog;             // Action-oriented
pub struct DatabaseConnection;         // Descriptive

// ❌ Bad naming examples
pub struct UserServiceImpl;            // Unnecessary "Impl" suffix
pub struct Helper;                     // Too generic
pub struct Manager;                    // Vague responsibility
```

## 🧪 TESTING STANDARDS

### Unit Test Placement
```rust
// ✅ Always place unit tests in the same file
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_validation() {
        let validator = UserValidator::new();
        let user = User::default();
        assert!(validator.validate(&user).is_ok());
    }
}

// ❌ Don't create separate test files for unit tests
// tests/user_test.rs (this is for integration tests only)
```

### Test Naming
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_email_passes_validation() {
        // Test name clearly describes the scenario
    }

    #[test]
    fn test_empty_email_returns_error() {
        // Specific about what's being tested
    }
}
```

## 📝 DOCUMENTATION STANDARDS

### Code Documentation
```rust
/// Validates user data according to business rules.
///
/// # Examples
///
/// ```rust
/// let validator = UserValidator::new();
/// let user = User::builder()
///     .email("user@example.com")
///     .display_name("John Doe")
///     .build();
///
/// assert!(validator.validate(&user).is_ok());
/// ```
///
/// # Errors
///
/// Returns `ValidationError` if:
/// - Email is empty or invalid format
/// - Display name is too long
/// - Required fields are missing
pub struct UserValidator {
    rules: Vec<ValidationRule>,
}
```

## 🚨 ANTI-PATTERNS TO AVOID

### Code Organization Anti-Patterns
```rust
// ❌ Don't use generic file names
// src/models.rs - mixing unrelated types
// src/utils.rs - catch-all for random functions
// src/helpers.rs - unclear responsibility

// ❌ Don't use implementation suffixes
pub struct UserValidatorImpl;
pub struct DatabaseManagerImpl;

// ❌ Don't mix concerns in single files
// src/app.rs containing database, validation, and HTTP logic

// ❌ Don't use overly long files
// Any file > 500 lines (excluding tests) needs refactoring
```

### Dependency Anti-Patterns
```rust
// ❌ Don't duplicate workspace dependencies
[dependencies]
tokio = "1.0"  # Already in workspace

// ❌ Don't modify Cargo.toml without permission
# Always ask before adding new dependencies

// ❌ Don't use outdated versions
serde = "0.9"  # Use latest stable
```

## ✅ QUALITY CHECKLIST

```markdown
### Code Quality Verification
- [ ] Uses Rust 2024 edition
- [ ] No `unsafe` code blocks
- [ ] No `unwrap()` or `expect()` in production code
- [ ] All data structures use `#[serde(rename_all = "camelCase")]`
- [ ] Files organized by functionality, not type
- [ ] Meaningful names (no "Impl" suffixes)
- [ ] Functions ≤ 150 lines
- [ ] Files ≤ 500 lines (excluding tests)
- [ ] Unit tests in same file as implementation
- [ ] `cargo build` passes
- [ ] `cargo test` passes
- [ ] `cargo clippy` passes with no warnings
- [ ] Public APIs documented with examples
- [ ] Workspace dependencies used when available
```

This code quality standard ensures consistent, maintainable, and production-ready Rust code across all projects.
