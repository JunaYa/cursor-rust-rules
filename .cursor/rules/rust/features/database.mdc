---
description:
globs:
alwaysApply: false
---
# üóÑÔ∏è RUST DATABASE BEST PRACTICES

> **TL;DR:** Comprehensive guidelines for database access in Rust using SQLx, focusing on type safety, async patterns, and testing strategies.

## üéØ DATABASE LIBRARY SELECTION

### SQLx as the Standard
- **Always use SQLx** - avoid `rusqlite`, `tokio-postgres`, or other lower-level libraries
- **Support multiple databases** through SQLx's unified interface
- **Leverage compile-time query checking** when possible
- **Use async/await patterns** for all database operations

```toml
# Cargo.toml - SQLx configuration
[dependencies]
sqlx = { workspace = true, features = ["runtime-tokio-rustls", "postgres", "sqlite", "uuid", "chrono", "json"] }
```

## üîß QUERY PATTERNS

### Use sqlx::query_as Instead of Macros
```rust
// ‚úÖ Preferred: Use sqlx::query_as with custom types
#[derive(Debug, Clone, sqlx::FromRow, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WorkflowExecution {
    pub id: Uuid,
    pub workflow_id: String,
    pub status: ExecutionStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub metadata: Option<serde_json::Value>,
}

impl WorkflowExecution {
    pub async fn find_by_id(
        pool: &PgPool,
        id: Uuid
    ) -> Result<Option<Self>, sqlx::Error> {
        sqlx::query_as::<_, WorkflowExecution>(
            "SELECT id, workflow_id, status, created_at, updated_at, metadata
             FROM workflow_executions
             WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(pool)
        .await
    }

    pub async fn list_by_workflow(
        pool: &PgPool,
        workflow_id: &str,
        limit: i64,
        offset: i64,
    ) -> Result<Vec<Self>, sqlx::Error> {
        sqlx::query_as::<_, WorkflowExecution>(
            "SELECT id, workflow_id, status, created_at, updated_at, metadata
             FROM workflow_executions
             WHERE workflow_id = $1
             ORDER BY created_at DESC
             LIMIT $2 OFFSET $3"
        )
        .bind(workflow_id)
        .bind(limit)
        .bind(offset)
        .fetch_all(pool)
        .await
    }
}

// ‚ùå Avoid: sqlx::query! macro (compile-time dependencies)
// let result = sqlx::query!("SELECT * FROM users WHERE id = $1", user_id)
//     .fetch_one(pool)
//     .await?;
```

### Entity Definition Patterns
```rust
use sqlx::{FromRow, PgPool, Row};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, FromRow, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub is_active: bool,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CreateUserRequest {
    pub username: String,
    pub email: String,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UpdateUserRequest {
    pub username: Option<String>,
    pub email: Option<String>,
    pub is_active: Option<bool>,
}
```

## üèóÔ∏è REPOSITORY PATTERN

### Repository Implementation
```rust
use async_trait::async_trait;
use sqlx::PgPool;
use uuid::Uuid;

#[async_trait]
pub trait UserRepository {
    async fn create(&self, request: CreateUserRequest) -> Result<User, sqlx::Error>;
    async fn find_by_id(&self, id: Uuid) -> Result<Option<User>, sqlx::Error>;
    async fn find_by_email(&self, email: &str) -> Result<Option<User>, sqlx::Error>;
    async fn update(&self, id: Uuid, request: UpdateUserRequest) -> Result<Option<User>, sqlx::Error>;
    async fn delete(&self, id: Uuid) -> Result<bool, sqlx::Error>;
    async fn list(&self, limit: i64, offset: i64) -> Result<Vec<User>, sqlx::Error>;
}

pub struct PostgresUserRepository {
    pool: PgPool,
}

impl PostgresUserRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for PostgresUserRepository {
    async fn create(&self, request: CreateUserRequest) -> Result<User, sqlx::Error> {
        let id = Uuid::new_v4();
        let now = Utc::now();

        sqlx::query_as::<_, User>(
            "INSERT INTO users (id, username, email, created_at, updated_at, is_active)
             VALUES ($1, $2, $3, $4, $5, $6)
             RETURNING id, username, email, created_at, updated_at, is_active"
        )
        .bind(id)
        .bind(&request.username)
        .bind(&request.email)
        .bind(now)
        .bind(now)
        .bind(true)
        .fetch_one(&self.pool)
        .await
    }

    async fn find_by_id(&self, id: Uuid) -> Result<Option<User>, sqlx::Error> {
        sqlx::query_as::<_, User>(
            "SELECT id, username, email, created_at, updated_at, is_active
             FROM users WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await
    }

    async fn find_by_email(&self, email: &str) -> Result<Option<User>, sqlx::Error> {
        sqlx::query_as::<_, User>(
            "SELECT id, username, email, created_at, updated_at, is_active
             FROM users WHERE email = $1"
        )
        .bind(email)
        .fetch_optional(&self.pool)
        .await
    }

    async fn update(&self, id: Uuid, request: UpdateUserRequest) -> Result<Option<User>, sqlx::Error> {
        let now = Utc::now();

        sqlx::query_as::<_, User>(
            "UPDATE users
             SET username = COALESCE($2, username),
                 email = COALESCE($3, email),
                 is_active = COALESCE($4, is_active),
                 updated_at = $5
             WHERE id = $1
             RETURNING id, username, email, created_at, updated_at, is_active"
        )
        .bind(id)
        .bind(request.username)
        .bind(request.email)
        .bind(request.is_active)
        .bind(now)
        .fetch_optional(&self.pool)
        .await
    }

    async fn delete(&self, id: Uuid) -> Result<bool, sqlx::Error> {
        let result = sqlx::query("DELETE FROM users WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;

        Ok(result.rows_affected() > 0)
    }

    async fn list(&self, limit: i64, offset: i64) -> Result<Vec<User>, sqlx::Error> {
        sqlx::query_as::<_, User>(
            "SELECT id, username, email, created_at, updated_at, is_active
             FROM users
             ORDER BY created_at DESC
             LIMIT $1 OFFSET $2"
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&self.pool)
        .await
    }
}
```

## üß™ DATABASE TESTING

### Using sqlx-db-tester for Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use sqlx_db_tester::TestPg;

    async fn setup_test_db() -> PgPool {
        let tester = TestPg::new(
            "postgres://postgres:password@localhost/test".to_string(),
            std::path::Path::new("./migrations"),
        );
        let pool = tester.get_pool().await;

        // Run migrations
        sqlx::migrate!("./migrations").run(&pool).await.unwrap();

        pool
    }

    #[tokio::test]
    async fn test_create_user() {
        let pool = setup_test_db().await;
        let repo = PostgresUserRepository::new(pool);

        let request = CreateUserRequest {
            username: "testuser".to_string(),
            email: "test@example.com".to_string(),
        };

        let user = repo.create(request).await.unwrap();
        assert_eq!(user.username, "testuser");
        assert_eq!(user.email, "test@example.com");
        assert!(user.is_active);
    }

    #[tokio::test]
    async fn test_find_user_by_email() {
        let pool = setup_test_db().await;
        let repo = PostgresUserRepository::new(pool);

        // Create a user first
        let create_request = CreateUserRequest {
            username: "findme".to_string(),
            email: "findme@example.com".to_string(),
        };
        let created_user = repo.create(create_request).await.unwrap();

        // Find by email
        let found_user = repo.find_by_email("findme@example.com").await.unwrap();
        assert!(found_user.is_some());
        assert_eq!(found_user.unwrap().id, created_user.id);
    }

    #[tokio::test]
    async fn test_update_user() {
        let pool = setup_test_db().await;
        let repo = PostgresUserRepository::new(pool);

        // Create a user
        let create_request = CreateUserRequest {
            username: "updateme".to_string(),
            email: "updateme@example.com".to_string(),
        };
        let user = repo.create(create_request).await.unwrap();

        // Update the user
        let update_request = UpdateUserRequest {
            username: Some("updated_name".to_string()),
            email: None,
            is_active: Some(false),
        };

        let updated_user = repo.update(user.id, update_request).await.unwrap();
        assert!(updated_user.is_some());
        let updated_user = updated_user.unwrap();
        assert_eq!(updated_user.username, "updated_name");
        assert!(!updated_user.is_active);
    }
}
```

## üìã MIGRATION PATTERNS

### Migration File Structure
```sql
-- migrations/20240501000001_create_users_table.sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    is_active BOOLEAN NOT NULL DEFAULT true
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Add trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## üîß CONNECTION MANAGEMENT

### Database Pool Configuration
```rust
use sqlx::{postgres::PgPoolOptions, PgPool};
use std::time::Duration;

pub async fn create_connection_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {
    PgPoolOptions::new()
        .max_connections(20)
        .min_connections(5)
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(1800))
        .connect(database_url)
        .await
}

// Application setup
pub async fn setup_database(config: &DatabaseConfig) -> Result<PgPool, Box<dyn std::error::Error>> {
    let pool = create_connection_pool(&config.url).await?;

    // Run migrations
    sqlx::migrate!("./migrations").run(&pool).await?;

    Ok(pool)
}
```

## üö® ANTI-PATTERNS TO AVOID

### Database Anti-Patterns
```rust
// ‚ùå Don't use rusqlite or tokio-postgres directly
// use rusqlite::{Connection, Result};
// use tokio_postgres::{NoTls, connect};

// ‚ùå Don't use sqlx::query! macro in production
// let user = sqlx::query!("SELECT * FROM users WHERE id = $1", id)
//     .fetch_one(pool)
//     .await?;

// ‚ùå Don't create entities without FromRow
// struct User {
//     id: Uuid,
//     name: String,
// }
// // Missing: #[derive(FromRow)]

// ‚ùå Don't forget serde camelCase configuration
// #[derive(Serialize, Deserialize)]
// struct User {  // Missing: #[serde(rename_all = "camelCase")]
//     user_id: String,
// }

// ‚ùå Don't create repositories without async traits
// impl UserRepository {
//     fn find_by_id(&self, id: Uuid) -> User {  // Should be async
//         // ...
//     }
// }
```

## ‚úÖ DATABASE CHECKLIST

```markdown
### Database Implementation Verification
- [ ] Uses SQLx (not rusqlite/tokio-postgres)
- [ ] Entities derive `FromRow`, `Serialize`, `Deserialize`
- [ ] All serde structs use `#[serde(rename_all = "camelCase")]`
- [ ] Uses `sqlx::query_as` instead of `sqlx::query!` macro
- [ ] Repository pattern with async traits
- [ ] Comprehensive unit tests with sqlx-db-tester
- [ ] Migration files in `migrations/` directory
- [ ] Connection pool properly configured
- [ ] Proper error handling (no unwrap/expect)
- [ ] All database operations are async
- [ ] Tests cover CRUD operations
- [ ] Indexes defined for query performance
```

This database standard ensures type-safe, performant, and testable database access patterns across Rust applications.
